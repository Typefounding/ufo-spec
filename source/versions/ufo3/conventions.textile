<div class="section">

h1. Conventions

These are conventions that are used throughout the UFO.

h3(#reversedomain). Reverse Domain Naming Schemes

In several places in the UFO the <a href="http://en.wikipedia.org/wiki/Reverse-DNS" target="_blank">reverse domain naming system</a> is recommended for creating unique keys and ids. To make a reverse domain, reverse the relevant Internet domain. For example, if the Internet domain is _unifiedfontobject.org_, the reverse domain name would be _org.unifiedfontobject_. Further extensions to make the string unique may be added. For example, _org.unifiedfontobject.MySpecialTool_.

h3(#usernametofilename). Common User Name to File Name Algorithm

This algorithm has limited support for case insensitive file systems: it assumes user names are not case sensitive apart from the first character.

# If a name starts with a ".":
## Replace the "." with an "_". Some file systems regard file names that start with "." as invisible.
# Break the name into parts delimited by ".".
# *If the first part contains one or more underscores*, it is a compound name.
## Split the compound name by underscore into its member names.
## To each member starting with a capital letter, add a "_" at the end.
## Rejoin the member names with underscore.
# *If the first part contains no underscore:*
## If it starts with a capital letter, add a "_" to the end.
# Rejoin the parts with ".".

h4. Examples

|_. glyph name              |_. file name |
| <pre>a</pre>              | <pre>a</pre> |
| <pre>A</pre>              | <pre>A_</pre> |
| <pre>A.alt</pre>          | <pre>A_.alt</pre> |
| <pre>T_H</pre>            | <pre>T__H_</pre> |
| <pre>T_h</pre>            | <pre>T__h</pre> |
| <pre>t_h</pre>            | <pre>t_h</pre> |
| <pre>F_F_I</pre>          | <pre>F__F__I_</pre> |
| <pre>f_f_i</pre>          | <pre>f_f_i</pre> |
| <pre>Aacute_V.swash</pre> | <pre>Aacute__V_.swash</pre> |


h5. Possible problems

# Some file systems impose file name length restrictions. This can cause file name clashes.
# The assumption that glyph names are not case sensitive apart from the first character causes problems with glyph names like _A.alt_ and _A.Alt_.

<div class="discussionnote">
This is a proposal for a revised version of the algorithm above. It has been designed to avoid name clashes and work with common file systems. It applies the following rules:

# Filenames must be unique.
# Filenames must be case insensitive.
# Filenames may use any character that can be represented by UTF-8 except: &quot; * + / : < > ? [ \ ] null | and anything in the range 1-31. <span class="inlineeditorsnote">Give hex values for these characters.</span>
# Filenames must be no longer than 255 characters.

<ul class="algorithm">
  <li>
    _name_ is the user name without any required prefix or suffix.
  </li>
  <li>
    _maximum length_ is 255 minus the length of a prefix and/or suffix that will be added to the name.
  </li>
  <li>
    Remove any illegal characters from _name_, where the illegal characters are: &quot; * + / : < > ? [ \ ] null | and anything in the range 1-31.
  </li>
  <li>
    Perform a generic translation of the name without consideration for existing names:
  </li>
  <li>
    <ul class="algorithm-nest">
      <li>
        _underscore parts_ is _name_ broken into parts delimited by underscore.
      </li>
      <li>
        For _part 1_ in these _underscore parts_:
      </li>
      <li>
        <ul class="algorithm-nest">
          <li>
            _period parts_ is _part 1_ broken into parts delimited by period.
          </li>
          <li>
            For _part 2_ in _period parts_:
          </li>
          <li>
            <ul class="algorithm-nest">
              <li>
                If _part 2_ starts with an uppercase letter:
              </li>
              <li>
                <ul class="algorithm-nest">
                  <li>
                    Add an underscore to the end of the part.
                  </li>
                </ul>
              </li>
            </ul>
          <li>
            Rejoin _period parts_ with periods.
          </li>
        </ul>
      </li>
      <li>
        Rejoin _underscore parts_ with underscores.
      </li>
      <li>
        If the revised _name_ is longer than _maximum length_:
      </li>
      <li>
        <ul class="algorithm-nest">
          <li>
            Remove as many characters from the end of _name_ as needed to make _name_ no longer than _maximum length_.
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    If _name_ is unique:
  </li>
  <li>
    <ul class="algorithm-nest">
      <li>
        Stop.
      </li>
    </ul>
  </li>
  <li>
    If _name_ is not unique:
  </li>
  <li>
    <ul class="algorithm-nest">
      <li>
        Remove as many characters from the end of _name_ as needed to make _name_ no longer than _maximum length_ minus 15.
      </li>
      <li>
        Starting with 000000000000001, add 15 zero filled characters to the name.
      </li>
      <li>
        If _name_ is unique:
      </li>
      <li>
        <ul class="algorithm-nest">
          <li>
            Stop.
          </li>
        </ul>
      </li>
      <li>
        Otherwise increment the number by 1 and repeat until a unique name is found or 999999999999999 is reached.
      </li>
    </ul>
  </li>
  <li>
    If _name_ is not unique:
  </li>
  <li>
    <ul class="algorithm-nest">
      <li>
        _number_ is 1.
      </li>
      <li>
        _name_ is _number_.
      </li>
      <li>
        If _name_ is unique:
      </li>
      <li>
        <ul class="algorithm-nest">
          <li>
            Stop.
          </li>
        </ul>
      </li>
      <li>
        Otherwise increment number by 1 and repeat until a unique name is found or all possible numbers in a string _maximum length_ long has been reached.
      </li>
    </ul>
  </li>
  <li>
    If _name_ is not unique:
  </li>
  <li>
    <ul class="algorithm-nest">
      <li>
        Raise an error and let the user know that after trying more than 10<sup>255</sup> names, nothing unique could be found.
      </li>
    </ul>
  </li>
</ul>

h5. Example implementation:

<pre class="prettyprint">
illegalCharacters = "\" * + / : < > ? [ \ ] | \0".split(" ")
illegalCharacters += [chr(i) for i in range(1, 32)]

def userNameToFileName(userName, existing=[], prefix="", suffix=""):
    """
    >>> userNameToFileName(u"a")
    u'a'
    >>> userNameToFileName(u"A")
    u'A_'
    >>> userNameToFileName(u"a.alt")
    u'a.alt'
    >>> userNameToFileName(u"A.alt")
    u'A_.alt'
    >>> userNameToFileName(u"a.Alt")
    u'a.Alt_'
    >>> userNameToFileName(u"A.alt")
    u'A_.alt'
    >>> userNameToFileName(u"T_H")
    u'T__H_'
    >>> userNameToFileName(u"T_h")
    u'T__h'
    >>> userNameToFileName(u"t_h")
    u't_h'
    >>> userNameToFileName(u"F_F_I")
    u'F__F__I_'
    >>> userNameToFileName(u"f_f_i")
    u'f_f_i'
    >>> userNameToFileName(u"Aacute_V.swash")
    u'Aacute__V_.swash'
    >>> userNameToFileName(u".notdef")
    u'_notdef'
    """
    # the incoming name must be a unicode string
    assert isinstance(userName, unicode), "The value for userName must be a unicode string."
    # establish the prefix and suffix lengths
    prefixLength = len(prefix)
    suffixLength = len(suffix)
    # filter illegal characters
    for c in illegalCharacters:
        userName = userName.replace(c, "")
    # replace an initial . with an _
    if userName[0] == ".":
        userName = "_" + userName[1:]
    # replace iniatl uppercase characters in parts delimited
    # by _ and then . with the character followed by an underscore
    underscoreParts = []
    for underscorePart in userName.split("_"):
        periodParts = []
        for periodPart in underscorePart.split("."):
            if len(periodPart) and periodPart[0] != periodPart[0].lower():
                periodPart += "_"
            periodParts.append(periodPart)
        underscorePart = ".".join(periodParts)
        underscoreParts.append(underscorePart)
    userName = "_".join(underscoreParts)
    # clip to 255
    sliceLength = 255 - prefixLength - suffixLength
    userName = userName[:sliceLength]
    # test for clash
    fullName = prefix + userName + suffix
    if fullName in existing:
        fullName = handleClash1(userName, existing, prefix, suffix)
    # finished
    return fullName

def handleClash1(userName, existing=[], prefix="", suffix=""):
    """
    >>> prefix = ("0" * 5) + "."
    >>> suffix = "." + ("0" * 10)
    >>> existing = ["A" * 20]

    >>> e = list(existing)
    >>> handleClash1(userName="A" * 20, existing=e, prefix=prefix, suffix=suffix)
    '00000.AAAAA000000000000001.0000000000'

    >>> e = list(existing)
    >>> e.append(prefix + "AAAAA" + "1".zfill(15) + suffix)
    >>> handleClash1(userName="A" * 20, existing=e, prefix=prefix, suffix=suffix)
    '00000.AAAAA000000000000002.0000000000'

    >>> e = list(existing)
    >>> e.append(prefix + "AAAAA" + "2".zfill(15) + suffix)
    >>> handleClash1(userName="A" * 20, existing=e, prefix=prefix, suffix=suffix)
    '00000.AAAAA000000000000001.0000000000'
    """
    # silce 15 characters off of the user name
    userName = userName[:-15]
    finalName = None
    # try to add numbers to create a unique name
    counter = 1
    while finalName is None:
        name = userName + str(counter).zfill(15)
        fullName = prefix + name + suffix
        if fullName not in existing:
            finalName = fullName
            break
        else:
            counter += 1
        if counter >= 999999999999999:
            break
    # if there is a clash, go to the next fallback
    if finalName is None:
        finalName = handleClash2(existsing, prefix, suffix)
    # finished
    return finalName

def handleClash2(existing=[], prefix="", suffix=""):
    """
    >>> prefix = ("0" * 5) + "."
    >>> suffix = "." + ("0" * 10)
    >>> existing = [prefix + str(i) + suffix for i in range(100)]

    >>> e = list(existing)
    >>> handleClash2(existing=e, prefix=prefix, suffix=suffix)
    '00000.100.0000000000'

    >>> e = list(existing)
    >>> e.remove(prefix + "1" + suffix)
    >>> handleClash2(existing=e, prefix=prefix, suffix=suffix)
    '00000.1.0000000000'

    >>> e = list(existing)
    >>> e.remove(prefix + "2" + suffix)
    >>> handleClash2(existing=e, prefix=prefix, suffix=suffix)
    '00000.2.0000000000'
    """
    # calculate the longest possible string
    maxLength = 255 - len(prefix) - len(suffix)
    maxValue = int("9" * maxLength)
    # try to find a number
    finalName = None
    counter = 1
    while finalName is None:
        fullName = prefix + str(counter) + suffix
        if fullName not in existing:
            finalName = fullName
            break
        else:
            counter += 1
        if counter >= maxValue:
            break
    # raise an error if nothing has been found
    if finalName is None:
        raise NameTranslationError("No unique name could be found.")
    # finished
    return finalName
</pre>

</div>


h3(#colors). Color Definitions

Several elements have a color attribute that defines a color value to be applied to the element. A color definition is defined as a string containing a comma-separated sequence of four integers or floats between 0 and 1. White space characters are allowed around the numerical values. The values in the string define the red, green, blue and alpha components of the color. The color is always specified in the "sRGB":http://en.wikipedia.org/wiki/SRGB color space.

<div class="discussionnote">
This is a string structured as a string like "0,0,0,1". This unusual structure is a result of the color being the value of an attribute of an element in GLIF in addition to a value in a property list. This string structure makes sense in GLIF but it is a little odd in property lists. An array of four numbers would make more sense there. Would having two structures be a problem?
</div>

<div class="editorsnote">
This needs a more clear definition in table form.
</div>

</div>