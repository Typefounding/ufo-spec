<div class="section">

h1. kerning.plist (draft)

table(even-columns).
| *File Format* | "XML Property List":http://www.apple.com/DTDs/PropertyList-1.0.dtd |

This file contains horizontal kerning pairs for the font. This file is optional. If it is not defined in the UFO, there is no horizontal kerning data.

h2. Specification

The property list data consists of a dictionary at the top level. Keys are _first_ member names and values are dictionaries. These dictionaries contain _second_ member names as keys and kerning values, either integer or float, as the values.

The kerning pair members are glyph names or group names. Group names used as the first member of a kerning pair must begin with the _firstKerningGroupPrefix_. Group names used as the second member of a kerning pair must begin with _secondKerningGroupPrefix_. The prefixes are defined in "fontinfo.plist":fontinfo.html#kerning-group-prefixes. Glyphs or groups in the pairs are not required to be in the font.

Kerning pairs that are not defined in kerning.plist implicitly have a value of "no kerning" or zero. Therefore any kerning pair that has a value of zero, unless it is a necessary value of an "exception":#kerning-pair-exceptions, should not be stored in kerning.plist.

h3(#writing-direction). Writing Direction

The kerning data is writing direction neutral. For text written left-to-right, the left-most glyph is the key in the top level dictionary. For text written right-to-left, the right-most glyph is the key in the top level dictionary. For example, given the pair _LG_, written left-to-right, the _L_ is the key in the top dictionary and the _G_ is the sub-dictionary. Given the pair _GL_, written right-to-left, the _G_ is the key in the top dictionary and the _L_ is the key in the sub-dictionary.

h3(#kerning-pair-types). Kerning Pair Types

<div class="editorsnote">
This section is a work in progress. Any feedback would be appreciated.
</div>

Kerning pairs may reference groups. This is done by using a "group's name":groups.html as a member of a kerning pair. These group members allow the kerning data to represent vast amounts of kerning with relatively few pairs. A pair member that contains a group implies that all members of the group are kerned with the other member of the pair with the same value (unless an exception is defined, see below). For example, a font has this group:

table(even-columns).
|_. name        |_. members |
| &#64;KERN_1_O | O, D, Q   |

The font's kerning contains a pair referencing this group:

table(even-columns).
|_. Side 1      |_. Side 2 |_. Value |
| &#64;KERN_1_O | A        | -50     |

This implies that the pair values for the specific glyphs combinations are as follows:

table(even-columns).
|_. Side 1 |_. Side 2 |_. Value |
| O        | A        | -50     |
| O        | A        | -50     |
| D        | A        | -50     |

The various combinations of glyphs and groups allow for three types of kerning pairs:

# Group combinations: group + group. For example, &#64;KERN_1_O + &#64;KERN_2_E.
# Glyph and group combinations: glyph + group and group + glyph. For example, A + &#64;KERN_2_E and &#64;KERN_1_O + A.
# Glyph combinations: glyph + glyph. For example, A + X.

h4(kerning-pair-exceptions). Exceptions

The kerning data may contain _exceptions_ to group pairs. The kerning pair types are organized in three levels:

Level 1: Group combinations.
Level 2: Glyph and group combinations.
Level 3: Glyph combinations.

Exception pairs may occur at the second and third levels. Second level pairs may be exceptions to first level pairs. Third level pairs may be exceptions to first and second level pairs.

For example, a font has these two groups:

table(even-columns).
|_. name        |_. members |
| &#64;KERN_1_O | O, D, Q   |
| &#64;KERN_2_E | E, F      |

The font's kerning contains a first level pair that references these two groups:

table(even-columns).
|_. Side 1      |_. Side 2      |_. Value |
| &#64;KERN_1_O | &#64;KERN_2_E | -100    |

The font's kerning contains a second level pair that forms an exception to the first level pair:

table(even-columns).
|_. Side 1      |_. Side 2 |_. Value |
| &#64;KERN_1_O | F        | -200    |

The font's kerning contains a third level pair that is an exception to both the first and second level pairs:

table(even-columns).
|_. Side 1 |_. Side 2 |_. Value |
| D        | F        | -300    |

This implies that the pair values for the specific glyphs combinations are as follows:

table(even-columns).
|_. Side 1 |_. Side 2 |_. Value |
| O        | E        | -100    |
| O        | F        | -200    |
| D        | E        | -100    |
| D        | F        | -300    |
| Q        | E        | -100    |
| Q        | F        | -200    |

h5. Exception Caveat

Exceptions are very powerful, but there is one rule that must be followed. There must not be contradictions within a level. For example, given the same &#64;KERN_1_O and &#64;KERN_2_E group as above, a font contains these following kerning pairs:

table(even-columns).
|_. Side 1      |_. Side 2      |_. Value |
| &#64;KERN_1_O | &#64;KERN_2_E | -100    |
| &#64;KERN_1_O | F             | -200    |
| Q             | &#64;KERN_2_E | -250    |
| D             | F             | -300    |

This implies that the pair values for the specific glyphs combinations are as follows:

table(even-columns).
|_. Side 1 |_. Side 2 |_. Value        |
| O        | E        | -100           |
| O        | F        | -200           |
| D        | E        | -100           |
| D        | F        | -300           |
| Q        | E        | -250           |
| Q        | F        | *-200 or -250* |

The two second level pairs, &#64;KERN_1_O + F and Q + &#64;KERN_2_E define two possible value for the pair Q + F. This is an unresolvable ambiguity. These types of contradictions must be avoided.

<div class="discussionnote">
Need to formulate this rule into a simple sentence and highlight it.
</div>

h4. Kerning Value Lookup Algorithm

The task of finding a value for a particular glyph + glyph combination is relatively easy. The following algorithm demonstrates a way that it can be done for a given pair.

<ul class="algorithm">
    <li>
      If the pair _first glyph + second glyph_ is in the kerning data:
    </li>
    <li>
      <ul class="algorithm-nest">
        <li>
          The value for _first glyph + second glyph_ is the value.
        </li>
        <li>
          Stop.
        </li>
      </ul>
    </li>
    <li>
      If the second glyph is in a kerning group:
    </li>
    <li>
      <ul class="algorithm-nest">
        <li>
          _second group_ is the name of the kerning group containing the second glyph.
        </li>
        <li>
          If the pair _first glyph + second group_ is in the kerning data:
        </li>
          <ul class="algorithm-nest">
            <li>
              The value for _first glyph + second group_ is the value.
            </li>
            <li>
              Stop.
            </li>
          </ul>
      </ul>
    </li>
    <li>
      If the first glyph is in a kerning group:
    </li>
    <li>
      <ul class="algorithm-nest">
        <li>
          _first group_ is the name of the kerning group containing the first glyph.
        </li>
        <li>
          If the pair _first group + second glyph_ is in the kerning data:
        </li>
          <ul class="algorithm-nest">
            <li>
              The value for _first first + second glyph_ is the value.
            </li>
            <li>
              Stop.
            </li>
          </ul>
      </ul>
    </li>
    <li>
      If the first glyph is in a kerning group and the second glyph is in a kerning group:
    </li>
    <li>
      <ul class="algorithm-nest">
        <li>
          _first group_ is the name of the kerning group containing the first glyph.
        </li>
        <li>
          _second group_ is the name of the kerning group containing the second glyph.
        </li>
        <li>
          If the pair _first group + second group_ is in the kerning data:
        </li>
          <ul class="algorithm-nest">
            <li>
              The value for _first group + second group_ is the value.
            </li>
            <li>
              Stop.
            </li>
          </ul>
      </ul>
    </li>
  <li>
    The value is zero.
  </li>
</ul>

h5. Sample implementation



<pre class="prettyprint">
def lookupKerningValue(pair, kerning, groups,
    firstKerningGroupPrefix, secondKerningGroupPrefix,
    fallback=0):
    """
    Note: This expects kerning to be a flat dictionary
    of kerning pairs, not the nested structure used
    in kerning.plist.

    >>> groups = {
    ...     "@KERN_1_O" : ["O", "D", "Q"],
    ...     "@KERN_2_E" : ["E", "F"]
    ... }
    >>> kerning = {
    ...     ("@KERN_1_O", "@KERN_2_E") : -100,
    ...     ("@KERN_1_O", "F") : -200,
    ...     ("D", "F") : -300
    ... }
    >>> fP = "@KERN_1_"
    >>> sP = "@KERN_2_"
    >>> lookupKerningValue(("D", "F"),
    ...     kerning, groups, fP, sP)
    -300
    >>> lookupKerningValue(("O", "F"),
    ...     kerning, groups, fP, sP)
    -200
    >>> lookupKerningValue(("O", "E"),
    ...     kerning, groups, fP, sP)
    -100
    >>> lookupKerningValue(("O", "O"),
    ...     kerning, groups, fP, sP)
    0
    >>> lookupKerningValue(("E", "E"),
    ...     kerning, groups, fP, sP)
    0
    >>> lookupKerningValue(("E", "O"),
    ...     kerning, groups, fP, sP)
    0
    >>> lookupKerningValue(("X", "X"),
    ...     kerning, groups, fP, sP)
    0
    >>> lookupKerningValue(("@KERN_1_O", "@KERN_2_E"),
    ...     kerning, groups, fP, sP)
    -100
    >>> lookupKerningValue(("@KERN_1_O", "F"),
    ...     kerning, groups, fP, sP)
    -200
    >>> lookupKerningValue(("O", "@KERN_2_E"),
    ....     kerning, groups, fP, sP)
    -100
    >>> lookupKerningValue(("@KERN_1_X", "@KERN_2_X"),
    ...     kerning, groups, fP, sP)
    0
    """
    # quickly check to see if the pair is in the kerning dictionary
    if pair in kerning:
        return kerning[pair]
    # get group names and make sure first and second are glyph names
    first, second = pair
    firstGroup = secondGroup = None
    if first.startswith(firstKerningGroupPrefix):
        firstGroup = first
        first = None
    else:
        for group, groupMembers in groups.items():
            if group.startswith(firstKerningGroupPrefix):
                if first in groupMembers:
                    firstGroup = group
                    break
    if second.startswith(secondKerningGroupPrefix):
        secondGroup = second
        second = None
    else:
        for group, groupMembers in groups.items():
            if group.startswith(secondKerningGroupPrefix):
                if second in groupMembers:
                    secondGroup = group
                    break
    # make an ordered list of pairs to look up
    pairs = [
        (first, second),
        (first, secondGroup),
        (firstGroup, second),
        (firstGroup, secondGroup)
    ]
    # look up the pairs and return any matches
    for pair in pairs:
        if pair in kerning:
            return kerning[pair]
    # use the fallback value
    return fallback
</pre>

h3. Example

<pre class="prettyprint">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple Computer//DTD PLIST 1.0//EN&quot;
&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
  &lt;key&gt;@KERN_1_BGroup&lt;/key&gt;
  &lt;dict&gt;
    &lt;key&gt;@KERN_2_CGroup&lt;/key&gt;
    &lt;integer&gt;7&lt;/integer&gt;
    &lt;key&gt;@KERN_2_DGroup&lt;/key&gt;
    &lt;integer&gt;8&lt;/integer&gt;
    &lt;key&gt;A&lt;/key&gt;
    &lt;integer&gt;5&lt;/integer&gt;
    &lt;key&gt;B&lt;/key&gt;
    &lt;integer&gt;6&lt;/integer&gt;
  &lt;/dict&gt;
  &lt;key&gt;@KERN_1_CGroup&lt;/key&gt;
  &lt;dict&gt;
    &lt;key&gt;@KERN_2_CGroup&lt;/key&gt;
    &lt;integer&gt;11&lt;/integer&gt;
    &lt;key&gt;@KERN_2_DGroup&lt;/key&gt;
    &lt;integer&gt;12&lt;/integer&gt;
    &lt;key&gt;A&lt;/key&gt;
    &lt;integer&gt;9&lt;/integer&gt;
    &lt;key&gt;B&lt;/key&gt;
    &lt;integer&gt;10&lt;/integer&gt;
  &lt;/dict&gt;
  &lt;key&gt;A&lt;/key&gt;
  &lt;dict&gt;
    &lt;key&gt;@KERN_2_CGroup&lt;/key&gt;
    &lt;integer&gt;3&lt;/integer&gt;
    &lt;key&gt;@KERN_2_DGroup&lt;/key&gt;
    &lt;integer&gt;4&lt;/integer&gt;
    &lt;key&gt;A&lt;/key&gt;
    &lt;integer&gt;1&lt;/integer&gt;
    &lt;key&gt;B&lt;/key&gt;
    &lt;integer&gt;2&lt;/integer&gt;
  &lt;/dict&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</pre>

</div>

<div class="section">

h1. Converting to UFO 3 formatted kerning

In UFO 1 and UFO 2, the implication was that if a member of a kerning pair had the same name as a group and a glyph, that member was the group. In UFO 3, this interpretation can be avoided by referencing the _firstKerningGroupPrefix_ and _secondKerningGroupPrefix_ found in "fontinfo.plist":fontinfo.html#kerning-group-prefixes. An algorithm for converting UFO 1 and UFO 2 group kerning is detailed below.

h3. Conversion algorithm

<ul class="algorithm">
  <li>
    Make a list of groups referenced on the first side of kerning pairs.
  </li>
  <li>
    For each of these groups:
  </li>
  <li>
    <ul class="algorithm-nest">
      <li>
        _original group name_ is the original group name.
      </li>
      <li>
        If _firstKerningGroupPrefix_ is not defined in fontinfo.plist:
      </li>
      <li>
        <ul class="algorithm-nest">
          <li>
            Set "&#64;KERN_1_" as the value for _firstKerningGroupPrefix_ in fontinfo.plist.
          </li>
        </ul>
      </li>
      <li>
        If _original group name_ does not begin with _firstKerningGroupPrefix_ as defined in fontinfo.plist:
      </li>
      <li>
        <ul class="algorithm-nest">
          <li>
            _new group name_ is _firstKerningGroupPrefix_ plus _original group name_.
          </li>
          <li>
            If _new group name_ is already in the groups:
          </li>
          <li>
            <ul class="algorithm-nest">
              <li>
                Beginning with 1, add a number to the end of _new group name_. Repeat until a unique name is found.
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        Copy the contents of the group and store them in groups.plist under _new group name_.
      </li>
      <li>
        Copy and remove the dictionary from kerning.plist that is stored under the key _original group name_.
      </li>
      <li>
        Add _new group name_ as a key to kerning.plist with the copied dictionary as the value.
      </li>
    </ul>
    <li>
      Make a list of groups referenced on the second side of kerning pairs.
    </li>
    <li>
      For each of these groups:
    </li>
    <li>
      <ul class="algorithm-nest">
        <li>
          _original group name_ is the original group name.
        </li>
        <li>
          If _secondKerningGroupPrefix_ is not defined in fontinfo.plist:
        </li>
        <li>
          <ul class="algorithm-nest">
            <li>
              Set "&#64;KERN_2_" as the value for _secondKerningGroupPrefix_ in fontinfo.plist.
            </li>
          </ul>
        </li>
        <li>
          If _original group name_ does not begin with _secondKerningGroupPrefix_ as defined in fontinfo.plist:
        </li>
        <li>
          <ul class="algorithm-nest">
            <li>
              _new group name_ is _secondKerningGroupPrefix_ plus _original group name_.
            </li>
            <li>
              If _new group name_ is already in the groups:
            </li>
            <li>
              <ul class="algorithm-nest">
                <li>
                  Beginning with 1, add a number to the end of _new group name_. Repeat until a unique name is found.
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
          Copy the contents of the group and store them in groups.plist under _new group name_.
        </li>
        <li>
          For each first glyph and dictionary in kerning.plist:
        </li>
        <li>
          <ul class="algorithm-nest">
            <li>
              If _original group name_ is a key in the dictionary:
            </li>
            <li>
              <ul class="algorithm-nest">
                <li>
                  Copy the _value_ stored under _original group name_.
                </li>
                <li>
                  Remove _original group name_ from the dictionary.
                </li>
                <li>
                  Add _new group name_ as a key in the dictionary with _value_ as the value.
                </li>
              </ul>
            </li>
          </ul>
      </ul>
</ul>

h3. Sample conversion implementation

<pre class="prettyprint">
def convertUFO1OrUFO2KerningToUFO3Kerning(kerning, groups,
    firstKerningGroupPrefix="@KERN_1_",
    secondKerningGroupPrefix="@KERN_2_"):
    # The prefixes must be unique.
    assert firstKerningGroupPrefix != secondKerningGroupPrefix
    # Make lists of groups referenced in kerning pairs.
    firstReferencedGroups = set()
    secondReferencedGroups = set()
    for first, seconds in kerning.items():
        if first in groups:
            if not first.startswith(firstKerningGroupPrefix):
                firstReferencedGroups.add(first)
        for second in seconds.keys():
            if second in groups:
                if not second.startswith(secondKerningGroupPrefix):
                    secondReferencedGroups.add(second)
    # Create new names for these groups.
    firstRenamedGroups = {}
    for first in firstReferencedGroups:
        # Make a list of existing group names.
        existingGroupNames = groups.keys() + firstRenamedGroups.keys()
        # Add the prefix to the name.
        newName = firstKerningGroupPrefix + first
        # Make a unique group name.
        newName = makeUniqueGroupName(newName, existingGroupNames)
        # Store for use later.
        firstRenamedGroups[first] = newName
    secondRenamedGroups = {}
    for second in secondReferencedGroups:
        # Make a list of existing group names.
        existingGroupNames = groups.keys() + secondRenamedGroups.keys()
        # Add the prefix to the name.
        newName = secondKerningGroupPrefix + second
        # Make a unique group name.
        newName = makeUniqueGroupName(newName, existingGroupNames)
        # Store for use later.
        secondRenamedGroups[second] = newName
    # Populate the new group names into the kerning dictionary as needed.
    newKerning = {}
    for first, seconds in kerning.items():
        first = firstRenamedGroups.get(first, first)
        newSeconds = {}
        for second, value in seconds.items():
            second = secondRenamedGroups.get(second, second)
            newSeconds[second] = value
        newKerning[first] = newSeconds
    # Make copies of the referenced groups and store them
    # under the new names in the overall groups dictionary.
    allRenamedGroups = firstRenamedGroups.items()
    allRenamedGroups += secondRenamedGroups.items()
    for oldName, newName in allRenamedGroups:
        group = list(groups[oldName])
        groups[newName] = group
    # Return the kerning and the groups.
    return newKerning, groups

def makeUniqueGroupName(name, groupNames, counter=0):
    # Add a number to the name if the counter is higher than zero.
    newName = name
    if counter > 0:
        newName = "%s%d" % (newName, counter)
    # If the new name is in the existing group names, recurse.
    if newName in groupNames:
        return makeUniqueGroupName(name, groupNames, counter + 1)
    # Otherwise send back the new name.
    return newName

def test():
    """
    >>> testKerning = {
    ...     "A" : {
    ...         "A" : 1,
    ...         "B" : 2,
    ...         "CGroup" : 3,
    ...         "DGroup" : 4
    ...     },
    ...     "BGroup" : {
    ...         "A" : 5,
    ...         "B" : 6,
    ...         "CGroup" : 7,
    ...         "DGroup" : 8
    ...     },
    ...     "CGroup" : {
    ...         "A" : 9,
    ...         "B" : 10,
    ...         "CGroup" : 11,
    ...         "DGroup" : 12
    ...     },
    ... }
    >>> testGroups = {
    ...     "BGroup" : ["B"],
    ...     "CGroup" : ["C"],
    ...     "DGroup" : ["D"],
    ... }
    >>> kerning, groups = convertUFO1OrUFO2KerningToUFO3Kerning(
    ...     testKerning, testGroups)
    >>> expected = {
    ...     "A" : {
    ...         "A": 1,
    ...         "B": 2,
    ...         "@KERN_2_CGroup": 3,
    ...         "@KERN_2_DGroup": 4
    ...     },
    ...     "@KERN_1_BGroup": {
    ...         "A": 5,
    ...         "B": 6,
    ...         "@KERN_2_CGroup": 7,
    ...         "@KERN_2_DGroup": 8
    ...     },
    ...     "@KERN_1_CGroup": {
    ...         "A": 9,
    ...         "B": 10,
    ...         "@KERN_2_CGroup": 11,
    ...         "@KERN_2_DGroup": 12
    ...     }
    ... }
    >>> kerning == expected
    True
    >>> expected = {
    ...     "BGroup": ["B"],
    ...     "CGroup": ["C"],
    ...     "DGroup": ["D"],
    ...     "@KERN_1_BGroup": ["B"],
    ...     "@KERN_1_CGroup": ["C"],
    ...     "@KERN_2_CGroup": ["C"],
    ...     "@KERN_2_DGroup": ["D"],
    ... }
    >>> groups == expected
    True
    """
</pre>

</div>