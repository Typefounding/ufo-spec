<div class="section">

h1. Glyph Interchange Format (draft)

| *File Format* | XML |

The Glyph Interchange Format (GLIF) is a simple and clear XML representation of a single glyph. GLIF files typically have a _.glif_ extension.

The GLIF data follows this structure:

<ul class="treediagram">
  <li class="treediagram">glyph</li>
  <ul class="treediagram">
    <li class="treediagram">advance</li>
    <li class="treediagram">unicode</li>
    <li class="treediagram">lib</li>
    <li class="treediagram">guideline</li>
    <li class="treediagram">image</li>
    <li class="treediagram">outline</li>
    <ul class="treediagram">
      <li class="treediagram">contour</li>
      <ul class="treediagram">
        <li class="treediagram">point</li>
      </ul>
      <li class="treediagram">component</li>
      <li class="treediagram">link</li>
      <ul class="treediagram">
        <li class="treediagram">pointref</li>
      </ul>
    </ul>
  </ul>
</ul>

h2. Specification

h3(#glyph). glyph: The top level element.

h4. Attributes

|_. attribute name |_. description |
| name             | The name of the glyph |
| format           | The format version. 2 for this version. |

The _name_ attribute has limited uses in this version. The _contents.plist_ file maps glyph names to file names, and one of the reasons to do this is to avoid having to parse all files just to get at a list of available glyph names. When reading GLIF files, the _name_ attribute should be ignored, since manual editing may have caused a mismatch with the glyph name as stored in _contents.plist_, as well as with the file name, which is an algorithmic transformation of the glyph name. This attribute may become more useful in future versions of GLIF.

h4. Child Elements

|_. element name         |_. description |
| "advance":#advance     | May occur at most once. |
| "unicode":#unicode     | May occur any number of times. |
| "image":#image         | May occur at most once. |
| "guideline":#guideline | May occur any number of times. |
| "link":#link           | May occur any number of times. |
| "outline":#outline     | May occur at most once. |
| "lib":#lib             | May occur at most once. |

h3(#advance). advance:  Horizontal and vertical metrics.

h4. Attributes

|_. attribute name |_. data type      |_. description |
| width            | integer or float | The advance width. |
| height           | integer or float | The vertical advance. |

h4. This element has no child elements.

h4. Example

<pre class="prettyprint">
&lt;advance width="400" /&gt;
</pre>


h3(#unicode). unicode: Unicode code point.

h4. Attributes

|_. attribute name |_. description |
| hex | A unicode code point as a hexadecimal number. |

h4. This element has no child elements.

The first occurrence of this element defines the primary unicode value for this glyph.

h4. Example

<pre class="prettyprint">
&lt;unicode hex="0041" /&gt;
</pre>


h3(#image). image:  An image reference.

This optional element represents an image element in a glyph. It may occur at most once. The image is always considered to be _behind_ the outline element.

<div class="implementationnote">
From an implementation perspective, images are quite complex. We either need to define a new pen like protocol for working with images or we need to define a standard API for getting and setting image data from/to glyphs.
</div>

h4. Attributes

|_. attribute name |_. data type |_. description |_. default value |
| fileName         | string      | The image file name, including any file extension, not an absolute or relative path in the file system. | None |
| xScale           | integer or float | See below. | 1 |
| xyScale          | integer or float | See below. | 0 |
| yxScale          | integer or float | See below. | 0 |
| yScale           | integer or float | See below. | 1 |
| xOffset          | integer or float | See below. | 0 |
| yOffset          | integer or float | See below. | 0 |
| color            | string | The color that should be applied to the image. The format follows the "color definition":#color standard. This attribute is optional. | None |

xScale, xyScale, yxScale, yScale, xOffset, yOffset taken together in that order form an Affine transformation matrix, to be used to transform the image. The default matrix is [1 0 0 1 0 0], the identity transformation.

h4. This element has no child elements.

h4. Format

All images must be in PNG format.

h4. Coloring Images

There are two places that the color for an image can be defined: the color attribute of the image element and the @fillColor@ defined in "layerinfo.plist":glyphs.html#layerinfo. The color defined in the image element's color attribute always takes precedence. If that is not defined and the @fillColor@ is defined for the layer, the layer's @fillColor@ should be used. If both of these are undefined, the image should not be colored. If a color is to be applied, the application should convert the image to grayscale and then apply the color. This modified version of the image must not be saved into the images directory.


h4. Example

<pre class="prettyprint">
&lt;image fileName=&quot;Sketch 1.png&quot; xOffset=&quot;100&quot; yOffset=&quot;200&quot;
  xScale=&quot;.75&quot; yScale=&quot;.75&quot; color=&quot;1,0,0,.5&quot; /&gt;
</pre>


h3(#guideline). guideline: A reference guideline.

This element may occur any number of times.

h4. Attributes

|_. attribute name |_. data type      |_. description |_. default value |
| x                | integer or float | The 'x' coordinate. | None. Optional if _y_ is provided and _angle_ is not provided. See below for details. |
| y                | integer or float | The 'y' coordinate. | None. Optional. See below for details. |
| angle            | integer or float | The angle of the guideline. This must be a value between 0 and 360 in a clockwise direction. If x or y are not specified, the angle must not be specified. If it is specified in this case, it should be ignored.| None |
| name             | string           | An arbitrary name for the guideline. This attribute is optional.  | None |
| color            | string           | The color that should be applied to the guideline. The format follows the "color definition":#color standard. This attribute is optional. | None |

The guideline extends along _angle_ to infinity in both directions out of the point defined by _x_ and _y_. If _y_ and _angle_ are omitted, the element represents a vertical guideline. If _x_ and _angle_ are omitted, the element represents a horizontal guideline. If _y_ is omitted and _angle_ if provided, _y_ is zero. If _x_ is omitted and _angle_ is provided, _x_ is zero.

<div class="discussionnote">
A proposed alternative format is to omit the the angle as described above and provide two pairs of x and y coordinates. The angle would be inferred from the two points. The argument for this is that it is potentially more precise. The arguments against it are that the precision difference is very small if it even exists and it is more data.
</div>

<div class="implementationnote">
Implementing this should be relatively easy. The guides could be stored in a list at attribute "guides" and glifLib could set/get them to/from there. Or pens and point pens could gain an addGuide method. The latter could be a breaking change though.

This is going to require defining an API or protocol. It seems that we should find a place to publish the various protocols and APIs to ensure interoperability. Perhaps another section of this site, completely separate from the specifications, would be good.
</div>

h4. Child Elements

This element has no child elements.


h3(#outline). outline: Outline description.

h4. This element has no attributes.

h4. Child Elements

|_. element name |_. description |
| component      | May occur any number of times. |
| contour        | May occur any number of times. |


h3(#component). component: Insert another glyph as part of the outline.

h4. Attributes

|_. attribute name |_. data type      |_. description          |_. default value |
| base             | string           | Name of the base glyph | None |
| xScale           | integer or float | See below.             | 1 |
| xyScale          | integer or float | See below.             | 0 |
| yxScale          | integer or float | See below.             | 0 |
| yScale           | integer or float | See below.             | 1 |
| xOffset          | integer or float | See below.             | 0 |
| yOffset          | integer or float | See below.             | 0 |

xScale, xyScale, yxScale, yScale, xOffset, yOffset taken together in that order form an Affine transformation matrix, to be used to transform the base glyph. The default matrix is [1 0 0 1 0 0], the identity transformation.

When multiple glyphs directories are in the font, a component may only reference a glyph within the same glyphs directory that contains the glyph that contains the component.

h4. This element has no child elements.

h4. Example

<pre class="prettyprint">
&lt;component base=&quot;A&quot; xOffset=&quot;100&quot; /&gt;
</pre>


h3(#contour). contour: Contour description.

h4. This element has no attributes.

h4. Child Elements

|_. element name |_. description |
| point          | May occur any number of times. |


h3(#point). point: An attributed coordinate pair.

h4. Attributes

|_. attribute name |_. data type      |_. description |_. default value |
| x                | integer or float | The 'x' coordinate. | None |
| y                | integer or float | The 'y' coordinate. | None |
| type             | string           | The point and/or segment type. The options are detailed below. | offcurve |
| smooth           | string           | This attribute can only be given when _type_ indicates the point is on-curve. When set to _yes_, it signifies that a smooth curvature should be maintained at this point, either as a _curve point_ or a _tangent point_ in Fontographer terms. | no |
| name             | string           | Arbitrary name or label for this point. The name does not have to be unique within a contour, nor within an outline. | None |
| identifier       | string           | Identifier for this point. The requirements for this attribute are detailed below. | None |

<div class="discussionnote">
Is the identifier attribute required? What should happen if an identifier is not present?
</div>

h5. Point Types

| move     | A point of this type MUST be the first in a _contour_. The reverse is not true: a _contour_ does not necessarily start with a _move_ point. When a _contour_ *does* start with a _move_ point, it signifies the beginning of an *open* contour. A *closed* contour does *not* start with a _move_ and is defined as a cyclic list of points, with no predominant start point. There is always a _next point_ and a _previous point_. For this purpose the list of points can be seen as endless in both directions. The actual list of points can be rotated arbitrarily (by removing the first N points and appending them at the end) while still describing the same outline. |
| line     | Draw a straight line from the previous point to this point. The previous point may be a _move_, a _line_, a _curve_ or a _qcurve_, but not an _offcurve_. |
| offcurve | This point is part of a curve segment, that goes up to the next point that is either a _curve_ or a _qcurve_. |
| curve    | Draw a cubic bezier curve from the last non-_offcurve_ point to this point. If the number of _offcurve_ points is zero, a straight line is drawn. If it is one, a quadratic curve is drawn. If it is two, a regular cubic bezier is drawn. If it is larger than 2, a series of cubic bezier segments are drawn, as defined by the _Super Bezier_ algorithm. |
| qcurve   | Similar to curve, but uses quadratic curves, using the TrueType "implied on-curve points" principle. |

<div class="discussionnote">
Should we remove the Super Bezier functionality? It creates an "interoperability problem":http://fontforge.sourceforge.net/python.html (search the page for "super-bezier").
</div>

h5. Point Identifier

Points may have an identifier attribute. This identifier must be unique within the glyph that the point belongs to but it is not required to be unique within the font that the point belongs to. The identifier must be string between one and 32 characters long. All characters must be in the printable ASCII range, <notextile>0x20</notextile> to <notextile>0x7E</notextile>.

<div class="discussionnote">
Should there be a note about not changing the identifiers willy-nilly?
</div>

There is no standard identifier generation algorithm but an example is detailed below.

h6. Example Algorithm

This algorithm is designed to generate a unique identifier that is a unique string consisting of between 1 and 32 numbers. This allows a glyph to contain 10<sup>32</sup>-1 points that follow this identifier naming scheme.

<div class="discussionnote">
This algorithm will work, but the identifiers look like indexes. They are not indexes, so this could be confusing.
</div>

<ul class="algorithm">
  <li>
    _existing identifiers_ is a ascending sorted list of existing identifiers in the glyph that can be converted losslessly to an integer.
  </li>
  <li>
    If _existing identifiers_ is empty:
  </li>
  <li>
    <ul class="algorithm-nest">
      <li>
        The identifier is the string representation of 1.
      </li>
      <li>
        Stop.
      </li>
    </ul>
  </li>
  <li>
    If the last item in the list is less than 10<sup>32</sup>-2:
  </li>
  <li>
    <ul class="algorithm-nest">
      <li>
        The identifier is the string representation of the last item in the list plus one.
      </li>
      <li>
        Stop.
      </li>
    </ul>
  </li>
  <li>
    If the last item in the list is 10<sup>32</sup>-1:
  </li>
  <li>
    <ul class="algorithm-nest">
      <li>
        Use a binary search to find a gap in the values in _existing identifiers_.
      </li>
      <li>
        If a gap is found:
      </li>
      <li>
        <ul class="algorithm-nest">
          <li>
            The identifier is the string representation of the first value in the gap.
          </li>
          <li>
            Stop.
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    If no unique value can be found:
  </li>
  <li>
    <ul class="algorithm-nest">
      <li>
        Raise an error and let the user know that after trying more than 10<sup>32</sup>-1 names, nothing unique could be found.
      </li>
    </ul>
  </li>
</ul>

*Sample implementation*

<pre class="prettyprint">
def findUniqueIdentifier(existingIdentifiers):
    """
    This assumes that existingIdentifiers is a sorted list of integers.

    >>> maxValue = 99999999999999999999999999999999
    >>> findUniqueIdentifier([])
    '1'
    >>> findUniqueIdentifier([1, 2])
    '3'
    >>> findUniqueIdentifier([1, 2, maxValue])
    '3'
    >>> findUniqueIdentifier(range(1, 10) + range(11, 20) + [maxValue])
    '10'
    >>> findUniqueIdentifier(range(1, 11) + range(12, 20) + [maxValue])
    '11'
    >>> findUniqueIdentifier(range(1, 9) + range(10, 20) + [maxValue])
    '9'
    """
    existingIdentifiers = [int(i) for i in existingIdentifiers]
    # if the list is empty, return 1
    if not existingIdentifiers:
        return "1"
    # check to see if it will even be possible to generate a value
    maxIdentifier = (10 ** 32) - 1
    if len(existingIdentifiers) >= maxIdentifier:
        raise NotImplementedError,\
        "This glyph has more than %d points." % maxIdentifier
    # if the last identifier is not the maximum possible value,
    # add one to the value
    if existingIdentifiers[-1] < maxIdentifier:
        return str(existingIdentifiers[-1] + 1)
    # otherwise use a binary search to find an opening
    return str(_findAvailableIdentifier(existingIdentifiers))

def _findAvailableIdentifier(existingIdentifiers):
    # work out where to slice
    count = len(existingIdentifiers)
    slicePoint = int(round(count / 2))
    # slice the list into two parts
    side1 = existingIdentifiers[:slicePoint]
    side2 = existingIdentifiers[slicePoint:]
    # if the end of the min of the second list - max of the first list
    # is geater than 1, the available identifier is max first list + 1
    if side2[0] - side1[-1] > 1:
        return side1[-1] + 1
    # if the max - min in a list is not the length of the list
    # there is an opening
    if side1[-1] - side1[0] >= len(side1):
        # if the length is now 2, the available identifier
        # is the first identifier + 1
        if len(side1) == 2:
            return side1[0] + 1
        return _findAvailableIdentifier(side1)
    else:
        # if the length is now 2, the available identifier
        # is the first identifier + 1
        if len(side2) == 2:
            return side2[0] + 1
        return _findAvailableIdentifier(side2)
</pre>

h4. This element has no child elements.

h4. Examples

move point:

<pre class="prettyprint">
&lt;point x=&quot;433&quot; y=&quot;371&quot; type=&quot;move&quot; /&gt;
</pre>

line point:

<pre class="prettyprint">
&lt;point x=&quot;433&quot; y=&quot;371&quot; type=&quot;line&quot; /&gt;
</pre>

offcurve point:

<pre class="prettyprint">
&lt;point x=&quot;433&quot; y=&quot;366&quot; /&gt;
</pre>

curve point:

<pre class="prettyprint">
&lt;point x=&quot;441&quot; y=&quot;363&quot; type=&quot;curve&quot; smooth=&quot;yes&quot; /&gt;
</pre>

qcurve point:

<pre class="prettyprint">
&lt;point x=&quot;441&quot; y=&quot;363&quot; type=&quot;qcurve&quot; /&gt;
</pre>


h3(#link). link: A collection of point references.

Links are arbitrary collections of point references. These can represent anything that can be described as a list of points--TrueType hints, Postscript hints, interpolation markers, etc. The GLIF specification does not define the behavior of links within a specific binary format. The _link_ element may contain a _type_ string that applications can use to define what a particular link represents.

This element may occur any number of times.

<div class="implementationnote">
Links are going to be a challenge to implement. There are two challenges: 1. How are they read from and written to a glyph object? Pen? Defined API and data structure? 2. How are they to be interpreted? In ufo2fdk it might be good to allow manual hinting via links. How will the package know which links to pay attention to? What is the structure of those links?

*Reading and Writing*
We could add an addLink(contourAndPointNamePairs, type, name=None) method pen and/or pointPen. This would be a breaking change that we could mitigate with try: except: and a deprecation warning while pens are still being updated. This raises the question: are links part of the outline? Pens are for transmitting outline data. The advantage with adding a method to the pens is that the responsibility for iterating and coercing to the proper structure is the duty of the appropriate object's draw and drawPoints methods.

Alternatively, we could set a new protocol for a standard links attribute and the pointref objects it contains. The advantage with this is that it won't break any pens. The disadvantage is that it gives glifLib more work to do.

*Interpretation*
If we have a standard link object, we need to have some standard structures that cover common uses. We can't make everything completely arbitrary because it will be too difficult for anything other than the creator of a particular link to interpret. It seems that defining two things would alleviate the ambiguity and promote interoperability.

First, we need to define a type naming scheme. Broadly, there are two types of links: links that are application specific and links that are not. In the case of application specific links, the type should be defined with a reverse domain naming scheme. @com.typesupply.SomeTool.Serif@. This way the maker of the link can identify the link as uniquely its own. Other applications can quickly see that the link type is unknown and choose to not display or display it in a generic way. For links that are not application specific, the @public.*@ naming scheme would be used. We would have a list of defined link types in the UFO specification.

Secondly, for these public.* links, we would need to define what the link would contain and how it should be interpreted. Some examples:

| public.horizontalStem | Two or more points defining a horizontal stem. Within the points there must be two unique y coordinates. |
| public.verticalStem | Two or more points defining a vertical stem. Within the points there must be two unique x coordinates. |
| public.counter | Two or more points defining a counter. |
| public.postscriptHintMask | (Definition from the T2 Charstring spec.) |
| public.postscriptCounterMask | (Definition from the T2 Charstring spec.) |

This puts us in the position of managing a registry, but it would only be for public types so it shouldn't be too complicated.

*objectsFL*
It is going to be quite a task to implement in FontLab 5. There are some hinting objects that could be abstracted into links via the RoboFab API. Those could then be written to and read from UFOs. I suppose that we could simulate point and contour names with str(index) for the object in question. This seems very fragile.
</div>

h4. Child Elements

|_. element name |_. description |
| pointref       | Must occur at least twice. |

h4. Attributes

|_. attribute name |_. data type |_. description |
| type             | string      | Optional. An arbitrary string describing the type of link. |
| name             | string      | Optional. Arbitrary name or label for this link. The name does not have to be unique. |

h4. Example

<pre class="prettyprint">
&lt;link type=&quot;vertical-stem&quot; name="stem 1"&gt;
  &lt;pointref point=&quot;4&quot;/&gt;
  &lt;pointref point=&quot;8&quot;/&gt;
&lt;/link&gt;
</pre>

h3(#pointref). pointref: A reference to a particular point in the glyph.

h4. This element has no child elements.

h4. Attributes

|_. attribute name |_. data type |_. description |
| point            | string      | The identifier attribute of the point being referenced. |


h3(#lib). lib: Custom data storage.

This element is a place to store tool specific, user specific or otherwise arbitrary data for the glyph. It is structure is defined as a "XML Property List":http://www.apple.com/DTDs/PropertyList-1.0.dtd. This element may occur at most once. lib has exactly one child, which must be _dict_. In order to prevent conflicts in the lib, keys in the top level should follow a "reverse domain naming scheme":conventions.html#reversedomain. It is recommended that the data stored as a value be as shallow as possible.

Data that is too complex or too large for lib can be stored in the "data directory":data.html.


h3. Example

<div class="editorsnote">
Bring this example up to date.
</div>

<pre class="prettyprint">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;glyph name=&quot;period&quot; format=&quot;1&quot;&gt;
  &lt;advance width=&quot;268&quot;/&gt;
  &lt;unicode hex=&quot;002E&quot;/&gt;
  &lt;outline&gt;
    &lt;contour&gt;
      &lt;point x=&quot;237&quot; y=&quot;152&quot;/&gt;
      &lt;point x=&quot;193&quot; y=&quot;187&quot;/&gt;
      &lt;point x=&quot;134&quot; y=&quot;187&quot; type=&quot;curve&quot; smooth=&quot;yes&quot;/&gt;
      &lt;point x=&quot;74&quot; y=&quot;187&quot;/&gt;
      &lt;point x=&quot;30&quot; y=&quot;150&quot;/&gt;
      &lt;point x=&quot;30&quot; y=&quot;88&quot; type=&quot;curve&quot; smooth=&quot;yes&quot;/&gt;
      &lt;point x=&quot;30&quot; y=&quot;23&quot;/&gt;
      &lt;point x=&quot;74&quot; y=&quot;-10&quot;/&gt;
      &lt;point x=&quot;134&quot; y=&quot;-10&quot; type=&quot;curve&quot; smooth=&quot;yes&quot;/&gt;
      &lt;point x=&quot;193&quot; y=&quot;-10&quot;/&gt;
      &lt;point x=&quot;237&quot; y=&quot;25&quot;/&gt;
      &lt;point x=&quot;237&quot; y=&quot;88&quot; type=&quot;curve&quot; smooth=&quot;yes&quot;/&gt;
    &lt;/contour&gt;
  &lt;/outline&gt;
  &lt;lib&gt;
    &lt;dict&gt;
      &lt;key&gt;com.letterror.somestuff&lt;/key&gt;
      &lt;string&gt;arbitrary custom data!&lt;/string&gt;
    &lt;/dict&gt;
  &lt;/lib&gt;
&lt;/glyph&gt;
</pre>

</div>